/// <reference types="node" />
import * as stream from 'stream';
export declare enum Direction {
    in = "in",
    out = "out"
}
export declare class IOData {
    private readonly io_id;
    fileName: string;
    direction: Direction;
    io: string;
    get ioID(): number;
    toIOData(): Object;
    constructor(filename: string, direction: Direction, io: string, ioID: number);
}
export declare abstract class BaseStep {
    abstract toStep(): Object | string;
}
export declare class Decode implements BaseStep {
    private readonly io_id;
    private readonly commands;
    toStep(): Object;
    get ioID(): number;
    constructor(ioID: number, commands?: DecodeOptions);
}
export declare abstract class Preset {
    abstract toPreset(): Object | string;
}
export declare class GIF implements Preset {
    toPreset(): string;
}
export declare class MozJPEG implements Preset {
    private readonly quality;
    private readonly isProgressive;
    private readonly matte;
    toPreset(): Object;
    constructor(quality: number, { isProgressive, matte, }?: {
        isProgressive?: boolean;
        matte?: Colors;
    });
}
export declare class LosslessPNG implements Preset {
    private readonly maximumDeflate;
    toPreset(): Object;
    constructor(maximumDeflate?: boolean);
}
export declare class LossyPNG implements Preset {
    private readonly quality;
    private readonly minimumQuality;
    private readonly speed;
    private readonly maxDeflate;
    toPreset(): Object;
    constructor(quality: number, minQuality: number, speed?: number | null, maxDeflate?: boolean);
}
export declare class WebP implements Preset {
    private readonly quality;
    toPreset(): Object;
    constructor(quality: number);
}
export declare class WebPLossless implements Preset {
    toPreset(): string;
}
export declare class Encode implements BaseStep {
    private preset;
    private readonly io_id;
    toStep(): Object;
    constructor(preset: Preset, ioId: number);
}
declare enum Filter {
    RobidouxFast = "robidoux_fast",
    Robidoux = "robidoux",
    RobidouxSharp = "robidoux_sharp",
    Ginseng = "ginseng",
    GinsengSharp = "ginseng_sharp",
    Lanczos = "lanczos",
    LanczosSharp = "lanczos_sharp",
    Lanczos2 = "lanczos_2",
    Lanczos2Sharp = "lanczos_2_sharp",
    Cubic = "cubic",
    CubicSharp = "cubic_sharp",
    CatmullRom = "catmull_rom",
    Mitchell = "mitchell",
    CubicBSpline = "cubic_b_spline",
    Hermite = "hermite",
    Jinc = "jinc",
    Triangle = "triangle",
    Linear = "linear",
    Box = "box",
    Fastest = "fastest",
    NCubic = "n_cubic",
    NCubicSharp = "n_cubic_sharp"
}
declare enum ResampleWhen {
    SizeDiffers = "size_differs",
    SizeDiffersOrSharpeningRequested = "size_differs_or_sharpening_requested",
    Always = "always"
}
declare enum SharpenWhen {
    Downscaling = "downscaling",
    Upscaling = "upscaling",
    SizeDiffers = "size_differs",
    Always = "always"
}
declare enum ScalingFloatspace {
    Srgb = "srgb",
    Linear = "linear"
}
interface ConstrainHintsOptions {
    downFilter?: Filter;
    upFilter?: Filter;
    scalingColorScape?: ScalingFloatspace;
    resampleWhen?: ResampleWhen;
    sharpenWhen?: SharpenWhen;
    backgroundColor?: Colors;
}
export declare class ConstrainHints {
    private readonly sharpenPercent;
    private downFilter;
    private upFilter;
    private scalingColorSpace;
    private resampleWhen;
    private sharpenWhen;
    private backgroundColor;
    toHint(): Object;
    constructor(sharpenPercent: number, { downFilter, upFilter, scalingColorScape, resampleWhen, sharpenWhen, backgroundColor, }?: ConstrainHintsOptions);
}
export declare class ConstrainGravity {
    private readonly x;
    private readonly y;
    toGravity(): Object;
    constructor(x: number, y: number);
}
export declare enum ConstrainMode {
    Distort = "distort",
    Within = "within",
    Fit = "fit",
    LargerThan = "larger_than",
    WithinCrop = "within_crop",
    FitCrop = "fit_crop",
    AspectCrop = "aspect_crop",
    WithinPad = "within_pad",
    FitPad = "fit_pad"
}
interface ConstrainOptions {
    canvasColor?: Colors;
    canvasGravity?: ConstrainGravity;
    hints?: ConstrainHints;
}
export declare class Constrain implements BaseStep {
    private hints?;
    private readonly width?;
    private readonly height?;
    private gravity?;
    private mode;
    private readonly canvasColor?;
    toStep(): Object;
    constructor(mode: ConstrainMode, width?: number | null, height?: number | null, { canvasColor, canvasGravity, hints, }?: ConstrainOptions);
}
export declare class RegionPercentage implements BaseStep {
    private readonly x1;
    private readonly y1;
    private readonly x2;
    private readonly y2;
    private backgroundColor;
    toStep(): Object;
    constructor({ x1, y1, x2, y2 }: FitBoxCoordinates, backgroundColor: Colors);
}
export declare class Region implements BaseStep {
    private readonly x1;
    private readonly y1;
    private readonly x2;
    private readonly y2;
    private backgroundColor;
    toStep(): Object;
    constructor({ x1, y1, x2, y2 }: FitBoxCoordinates, backgroundColor: Colors);
}
export declare class CropWhitespace implements BaseStep {
    private readonly threshold;
    private readonly padding;
    toStep(): Object;
    constructor(threshold: number, padding: number);
}
export declare class Rotate90 implements BaseStep {
    toStep(): string;
}
export declare class Rotate180 implements BaseStep {
    toStep(): string;
}
export declare class Rotate270 implements BaseStep {
    toStep(): string;
}
export declare class FlipV implements BaseStep {
    toStep(): string;
}
export declare class FlipH implements BaseStep {
    toStep(): string;
}
export declare class FillRect implements BaseStep {
    private readonly x1;
    private readonly x2;
    private readonly y1;
    private readonly y2;
    private readonly color;
    toStep(): Object;
    constructor(x1: number, y1: number, x2: number, y2: number, color: Colors);
}
export declare abstract class Colors {
    abstract toColor(): Object | string;
}
export declare enum ColorType {
    Hex = "hex"
}
export declare class SRGBColor implements Colors {
    private readonly type;
    private readonly value;
    toColor(): Object;
    constructor(type: ColorType, value: string);
}
export declare class TransparentColor implements Colors {
    toColor(): string;
}
export declare class BlackColor implements Colors {
    toColor(): string;
}
interface ExpandCanvasOptions {
    top: number;
    right: number;
    bottom: number;
    left: number;
}
export declare class ExpandCanvas implements BaseStep {
    private readonly top;
    private readonly right;
    private readonly bottom;
    private readonly left;
    private color;
    toStep(): Object;
    constructor({ top, left, right, bottom }: ExpandCanvasOptions, color: SRGBColor);
}
declare enum FitMode {
    Distort = "distort",
    Within = "within",
    Fit = "fit",
    WithinCrop = "within_crop",
    FitCrop = "fit_crop"
}
declare abstract class FitBox {
    abstract toFitBox(): Object;
}
interface FitBoxCoordinates {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
}
export declare class FitBoxPercentage implements FitBox {
    private readonly x1;
    private readonly y1;
    private readonly x2;
    private readonly y2;
    toFitBox(): Object;
    constructor({ x1, x2, y1, y2 }: FitBoxCoordinates);
}
export declare class FitBoxMargin implements FitBox {
    private readonly left;
    private readonly top;
    private readonly right;
    private readonly bottom;
    toFitBox(): Object;
    constructor({ top, left, right, bottom, }: ExpandCanvasOptions);
}
export interface WatermarkOption {
    gravity: ConstrainGravity;
    mode: FitMode;
    box: FitBox;
    opacity: number;
    hint: ConstrainHints;
}
export declare class Watermark implements BaseStep {
    private readonly ioID;
    private gravity;
    private readonly fitMode;
    private fitBox;
    private readonly opacity;
    private hint;
    toStep(): Object;
    constructor(ioID: number, { gravity, mode, box, opacity, hint }: WatermarkOption);
}
export declare class CommandString implements BaseStep {
    private readonly command;
    private readonly encode;
    private readonly decode;
    toStep(): Object;
    constructor(command: string, encode?: number | null, decode?: number | null);
}
export declare class WhiteBalance {
    private threshold;
    toStep(): Object;
    constructor(threshold: number);
}
export declare enum ColorFilterSRGBType {
    GrayscaleNtsc = "grayscale_ntsc",
    GrayscaleFlat = "grayscale_flat",
    GrayscaleBt709 = "grayscale_bt709",
    GrayscaleRY = "grayscale_ry",
    Invert = "invert"
}
export declare enum ColorFilterSRGBValueType {
    Alpha = "alpha",
    Contrast = "contrast",
    Brightness = "brightness"
}
export declare class ColorFilterSRGBValue {
    private value;
    private valueType;
    constructor(value: number, valueType: ColorFilterSRGBValueType);
    toFilter(): Object;
}
export declare class ColorFilterSRGB implements BaseStep {
    private filterType;
    toStep(): Object;
    constructor(filter: ColorFilterSRGBType | ColorFilterSRGBValue);
}
export interface DrawExactImageToCoordinates {
    x: number;
    y: number;
    w: number;
    h: number;
}
export declare class DrawExactImageTo implements BaseStep {
    private x;
    private y;
    private w;
    private h;
    private blend;
    private hint;
    toStep(): Object;
    constructor({ x, y, w, h }: DrawExactImageToCoordinates, blend: CompositingMode, hint: ConstrainHints);
}
export declare enum CompositingMode {
    Compose = "compose",
    Overwrite = "overwrite"
}
export declare class CopyRectangle implements BaseStep {
    private fromX;
    private fromY;
    private w;
    private h;
    private x;
    private y;
    toStep(): Object;
    constructor({ x, y, w, h }: DrawExactImageToCoordinates, fromX: number, fromY: number);
}
export declare abstract class IOOperation {
    abstract toIOBuffer(): Promise<ArrayBuffer | SharedArrayBuffer>;
    abstract toIOID(): Object;
    abstract setIOID(id: number, direction: Direction): void;
    abstract get ioID(): number;
    abstract toOutput(buffer: ArrayBuffer, collector: Object): Promise<any>;
}
export declare class FromFile implements IOOperation {
    private filename;
    private ioId;
    private direction;
    toIOBuffer(): Promise<ArrayBuffer | SharedArrayBuffer>;
    get ioID(): number;
    constructor(filename: string);
    setIOID(id: number, direction: Direction): void;
    toIOID(): Object;
    toOutput(buffer: ArrayBuffer, collector: Object): Promise<void>;
}
export declare class FromStream implements IOOperation {
    private ioId;
    private direction;
    private internalStream;
    constructor(str: stream.Stream);
    toIOBuffer(): Promise<ArrayBuffer | SharedArrayBuffer>;
    toIOID(): Object;
    setIOID(id: number, direction: Direction): void;
    get ioID(): number;
    toOutput(buffer: ArrayBuffer, collector: Object): Promise<void>;
}
export declare class FromBuffer implements IOOperation {
    private buffer;
    private ioId;
    private direction;
    private key;
    toIOBuffer(): Promise<ArrayBuffer | SharedArrayBuffer>;
    constructor(buf: Buffer, key: string);
    toIOID(): Object;
    setIOID(id: number, direction: Direction): void;
    get ioID(): number;
    toOutput(buffer: ArrayBuffer, collector: Object): Promise<any>;
}
export declare class FromURL implements IOOperation {
    private url;
    private ioId;
    private direction;
    toIOBuffer(): Promise<ArrayBuffer | SharedArrayBuffer>;
    get ioID(): number;
    constructor(url: string);
    setIOID(id: number, direction: Direction): void;
    toIOID(): Object;
    toOutput(buffer: ArrayBuffer, collector: Object): Promise<void>;
}
export declare class ReSample implements BaseStep {
    private w;
    private h;
    private hint;
    toStep(): Object;
    constructor(w: number, h: number, hint?: ConstrainHints | null);
}
export declare class DecodeOptions {
    private commands;
    private setJPEGDownscaleHintUsed;
    private discardColorProfileUsed;
    private ignoreColorProfileErrorUsed;
    private setWebpDecoderHintsUsed;
    constructor();
    toDecodeOptions(): Array<object | string>;
    setJPEGDownscaleHint(width: Number, height: Number, { scaleLumaSpatially, gammaCorrectForSrgbDuringSpatialLumaScaling, }?: {
        scaleLumaSpatially?: boolean;
        gammaCorrectForSrgbDuringSpatialLumaScaling?: boolean;
    }): DecodeOptions;
    discardColorProfile(): DecodeOptions;
    ignoreColorProfileError(): DecodeOptions;
    setWebpDecoderHints(width: Number, height: Number): DecodeOptions;
}
export {};
