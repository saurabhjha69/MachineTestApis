"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecodeOptions = exports.ReSample = exports.FromURL = exports.FromBuffer = exports.FromStream = exports.FromFile = exports.IOOperation = exports.CopyRectangle = exports.CompositingMode = exports.DrawExactImageTo = exports.ColorFilterSRGB = exports.ColorFilterSRGBValue = exports.ColorFilterSRGBValueType = exports.ColorFilterSRGBType = exports.WhiteBalance = exports.CommandString = exports.Watermark = exports.FitBoxMargin = exports.FitBoxPercentage = exports.ExpandCanvas = exports.BlackColor = exports.TransparentColor = exports.SRGBColor = exports.ColorType = exports.Colors = exports.FillRect = exports.FlipH = exports.FlipV = exports.Rotate270 = exports.Rotate180 = exports.Rotate90 = exports.CropWhitespace = exports.Region = exports.RegionPercentage = exports.Constrain = exports.ConstrainMode = exports.ConstrainGravity = exports.ConstrainHints = exports.Encode = exports.WebPLossless = exports.WebP = exports.LossyPNG = exports.LosslessPNG = exports.MozJPEG = exports.GIF = exports.Preset = exports.Decode = exports.BaseStep = exports.IOData = exports.Direction = void 0;
const fs = require("fs");
const axios_1 = require("axios");
const str = require('stream-promise');
var Direction;
(function (Direction) {
    Direction["in"] = "in";
    Direction["out"] = "out";
})(Direction = exports.Direction || (exports.Direction = {}));
class IOData {
    constructor(filename, direction, io, ioID) {
        this.direction = direction;
        this.io = io;
        this.io_id = ioID;
        this.fileName = filename;
    }
    get ioID() {
        return this.io_id;
    }
    toIOData() {
        return {
            io_id: this.io_id,
            direction: this.direction,
            io: this.io,
        };
    }
}
exports.IOData = IOData;
class BaseStep {
}
exports.BaseStep = BaseStep;
class Decode {
    constructor(ioID, commands = null) {
        this.io_id = ioID;
        this.commands = commands === null || commands === void 0 ? void 0 : commands.toDecodeOptions();
    }
    toStep() {
        return {
            decode: {
                io_id: this.io_id,
                commands: this.commands,
            },
        };
    }
    get ioID() {
        return this.io_id;
    }
}
exports.Decode = Decode;
class Preset {
}
exports.Preset = Preset;
class GIF {
    toPreset() {
        return 'gif';
    }
}
exports.GIF = GIF;
class MozJPEG {
    constructor(quality, { isProgressive, matte, } = {}) {
        if (quality > 100 || quality < 0)
            throw new Error('invalid quality for preset');
        this.isProgressive = isProgressive;
        this.quality = quality;
        this.matte = matte;
    }
    toPreset() {
        var _a;
        return {
            mozjpeg: {
                quality: this.quality,
                progressive: this.isProgressive,
                matte: (_a = this.matte) === null || _a === void 0 ? void 0 : _a.toColor(),
            },
        };
    }
}
exports.MozJPEG = MozJPEG;
class LosslessPNG {
    constructor(maximumDeflate = false) {
        this.maximumDeflate = maximumDeflate;
    }
    toPreset() {
        return {
            lodepng: {
                maximum_deflate: this.maximumDeflate,
            },
        };
    }
}
exports.LosslessPNG = LosslessPNG;
class LossyPNG {
    constructor(quality, minQuality, speed = null, maxDeflate = false) {
        if (quality > 100 || quality < 0)
            throw new Error('invalid quality for preset');
        if (minQuality > 100 || minQuality < 0)
            throw new Error('invalid minimum quality for preset');
        if (speed != null && (speed > 10 || speed < 0))
            throw new Error('invalid speed for preset');
        this.quality = quality;
        this.maxDeflate = maxDeflate;
        this.speed = speed;
        this.minimumQuality = minQuality;
    }
    toPreset() {
        return {
            pngquant: {
                quality: this.quality,
                minimum_quality: this.minimumQuality,
                speed: this.speed,
                maximum_deflate: this.maxDeflate,
            },
        };
    }
}
exports.LossyPNG = LossyPNG;
class WebP {
    constructor(quality) {
        if (quality > 100 || quality < 0)
            throw new Error('invalid quality for preset');
        this.quality = quality;
    }
    toPreset() {
        return {
            webplossy: {
                quality: this.quality,
            },
        };
    }
}
exports.WebP = WebP;
class WebPLossless {
    toPreset() {
        return 'webplossless';
    }
}
exports.WebPLossless = WebPLossless;
class Encode {
    constructor(preset, ioId) {
        this.io_id = ioId;
        this.preset = preset;
    }
    toStep() {
        var _a;
        return {
            encode: {
                io_id: this.io_id,
                preset: (_a = this.preset) === null || _a === void 0 ? void 0 : _a.toPreset(),
            },
        };
    }
}
exports.Encode = Encode;
var Filter;
(function (Filter) {
    Filter["RobidouxFast"] = "robidoux_fast";
    Filter["Robidoux"] = "robidoux";
    Filter["RobidouxSharp"] = "robidoux_sharp";
    Filter["Ginseng"] = "ginseng";
    Filter["GinsengSharp"] = "ginseng_sharp";
    Filter["Lanczos"] = "lanczos";
    Filter["LanczosSharp"] = "lanczos_sharp";
    Filter["Lanczos2"] = "lanczos_2";
    Filter["Lanczos2Sharp"] = "lanczos_2_sharp";
    Filter["Cubic"] = "cubic";
    Filter["CubicSharp"] = "cubic_sharp";
    Filter["CatmullRom"] = "catmull_rom";
    Filter["Mitchell"] = "mitchell";
    Filter["CubicBSpline"] = "cubic_b_spline";
    Filter["Hermite"] = "hermite";
    Filter["Jinc"] = "jinc";
    Filter["Triangle"] = "triangle";
    Filter["Linear"] = "linear";
    Filter["Box"] = "box";
    Filter["Fastest"] = "fastest";
    Filter["NCubic"] = "n_cubic";
    Filter["NCubicSharp"] = "n_cubic_sharp";
})(Filter || (Filter = {}));
var ResampleWhen;
(function (ResampleWhen) {
    ResampleWhen["SizeDiffers"] = "size_differs";
    ResampleWhen["SizeDiffersOrSharpeningRequested"] = "size_differs_or_sharpening_requested";
    ResampleWhen["Always"] = "always";
})(ResampleWhen || (ResampleWhen = {}));
var SharpenWhen;
(function (SharpenWhen) {
    SharpenWhen["Downscaling"] = "downscaling";
    SharpenWhen["Upscaling"] = "upscaling";
    SharpenWhen["SizeDiffers"] = "size_differs";
    SharpenWhen["Always"] = "always";
})(SharpenWhen || (SharpenWhen = {}));
var ScalingFloatspace;
(function (ScalingFloatspace) {
    ScalingFloatspace["Srgb"] = "srgb";
    ScalingFloatspace["Linear"] = "linear";
})(ScalingFloatspace || (ScalingFloatspace = {}));
class ConstrainHints {
    constructor(sharpenPercent, { downFilter, upFilter, scalingColorScape, resampleWhen, sharpenWhen, backgroundColor, } = {}) {
        this.sharpenPercent = sharpenPercent;
        this.downFilter = downFilter;
        this.upFilter = upFilter;
        this.scalingColorSpace = scalingColorScape;
        this.resampleWhen = resampleWhen;
        this.sharpenWhen = sharpenWhen;
        this.backgroundColor = backgroundColor;
    }
    toHint() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return {
            sharpen_percent: this.sharpenPercent,
            down_filter: (_b = (_a = this.downFilter) === null || _a === void 0 ? void 0 : _a.toString()) === null || _b === void 0 ? void 0 : _b.toLowerCase(),
            up_filter: (_d = (_c = this.upFilter) === null || _c === void 0 ? void 0 : _c.toString()) === null || _d === void 0 ? void 0 : _d.toLowerCase(),
            scaling_colorspace: (_e = this.scalingColorSpace) === null || _e === void 0 ? void 0 : _e.toString().toLowerCase(),
            resample_when: (_f = this.resampleWhen) === null || _f === void 0 ? void 0 : _f.toString(),
            sharpen_when: (_g = this.sharpenWhen) === null || _g === void 0 ? void 0 : _g.toString(),
            background_color: (_h = this.backgroundColor) === null || _h === void 0 ? void 0 : _h.toColor(),
        };
    }
}
exports.ConstrainHints = ConstrainHints;
class ConstrainGravity {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toGravity() {
        return {
            percentage: {
                x: this.x,
                y: this.y,
            },
        };
    }
}
exports.ConstrainGravity = ConstrainGravity;
var ConstrainMode;
(function (ConstrainMode) {
    ConstrainMode["Distort"] = "distort";
    ConstrainMode["Within"] = "within";
    ConstrainMode["Fit"] = "fit";
    ConstrainMode["LargerThan"] = "larger_than";
    ConstrainMode["WithinCrop"] = "within_crop";
    ConstrainMode["FitCrop"] = "fit_crop";
    ConstrainMode["AspectCrop"] = "aspect_crop";
    ConstrainMode["WithinPad"] = "within_pad";
    ConstrainMode["FitPad"] = "fit_pad";
})(ConstrainMode = exports.ConstrainMode || (exports.ConstrainMode = {}));
class Constrain {
    constructor(mode, width = null, height = null, { canvasColor = null, canvasGravity = null, hints = null, } = {}) {
        this.mode = mode;
        this.width = width;
        this.height = height;
        this.canvasColor = canvasColor;
        this.gravity = canvasGravity;
        this.hints = hints;
    }
    toStep() {
        var _a, _b, _c;
        return {
            constrain: {
                mode: this.mode.toString(),
                w: this.width,
                h: this.height,
                hints: (_a = this.hints) === null || _a === void 0 ? void 0 : _a.toHint(),
                gravity: (_b = this.gravity) === null || _b === void 0 ? void 0 : _b.toGravity(),
                canvas_color: (_c = this.canvasColor) === null || _c === void 0 ? void 0 : _c.toColor(),
            },
        };
    }
}
exports.Constrain = Constrain;
class RegionPercentage {
    constructor({ x1, y1, x2, y2 }, backgroundColor) {
        this.x1 = x1;
        this.y2 = y2;
        this.x2 = x2;
        this.y1 = y1;
        this.backgroundColor = backgroundColor;
    }
    toStep() {
        return {
            region_percent: {
                x1: this.x1,
                y1: this.y1,
                x2: this.x2,
                y2: this.y2,
                background_color: this.backgroundColor.toColor(),
            },
        };
    }
}
exports.RegionPercentage = RegionPercentage;
class Region {
    constructor({ x1, y1, x2, y2 }, backgroundColor) {
        this.x1 = x1;
        this.y2 = y2;
        this.x2 = x2;
        this.y1 = y1;
        this.backgroundColor = backgroundColor;
    }
    toStep() {
        return {
            region: {
                x1: this.x1,
                y1: this.y1,
                x2: this.x2,
                y2: this.y2,
                background_color: this.backgroundColor.toColor(),
            },
        };
    }
}
exports.Region = Region;
class CropWhitespace {
    constructor(threshold, padding) {
        if (padding < 0 || padding > 100)
            throw new Error('invalid value for percentage');
        if (threshold < 0 || threshold > 255)
            throw new Error('invalid value of threshold');
        this.padding = padding;
        this.threshold = threshold;
    }
    toStep() {
        return {
            crop_whitespace: {
                threshold: this.threshold,
                percent_padding: this.padding,
            },
        };
    }
}
exports.CropWhitespace = CropWhitespace;
class Rotate90 {
    toStep() {
        return 'rotate_90';
    }
}
exports.Rotate90 = Rotate90;
class Rotate180 {
    toStep() {
        return 'rotate_180';
    }
}
exports.Rotate180 = Rotate180;
class Rotate270 {
    toStep() {
        return 'rotate_270';
    }
}
exports.Rotate270 = Rotate270;
class FlipV {
    toStep() {
        return 'flip_v';
    }
}
exports.FlipV = FlipV;
class FlipH {
    toStep() {
        return 'flip_h';
    }
}
exports.FlipH = FlipH;
class FillRect {
    constructor(x1, y1, x2, y2, color) {
        this.x1 = x1;
        this.x2 = x2;
        this.y1 = y1;
        this.y2 = y2;
        this.color = color;
    }
    toStep() {
        var _a;
        return {
            fill_rect: {
                x1: this.x1,
                y1: this.y1,
                x2: this.x2,
                y2: this.y2,
                color: (_a = this.color) === null || _a === void 0 ? void 0 : _a.toColor(),
            },
        };
    }
}
exports.FillRect = FillRect;
class Colors {
}
exports.Colors = Colors;
var ColorType;
(function (ColorType) {
    ColorType["Hex"] = "hex";
})(ColorType = exports.ColorType || (exports.ColorType = {}));
class SRGBColor {
    constructor(type, value) {
        this.type = type;
        this.value = value;
    }
    toColor() {
        return {
            srgb: {
                [this.type]: this.value,
            },
        };
    }
}
exports.SRGBColor = SRGBColor;
class TransparentColor {
    toColor() {
        return 'transparent';
    }
}
exports.TransparentColor = TransparentColor;
class BlackColor {
    toColor() {
        return 'black';
    }
}
exports.BlackColor = BlackColor;
class ExpandCanvas {
    constructor({ top = 0, left = 0, right = 0, bottom = 0 }, color) {
        this.top = top;
        this.left = left;
        this.right = right;
        this.bottom = bottom;
        this.color = color;
    }
    toStep() {
        return {
            expand_canvas: {
                left: this.left,
                top: this.top,
                right: this.right,
                bottom: this.bottom,
                color: this.color.toColor(),
            },
        };
    }
}
exports.ExpandCanvas = ExpandCanvas;
var FitMode;
(function (FitMode) {
    FitMode["Distort"] = "distort";
    FitMode["Within"] = "within";
    FitMode["Fit"] = "fit";
    FitMode["WithinCrop"] = "within_crop";
    FitMode["FitCrop"] = "fit_crop";
})(FitMode || (FitMode = {}));
class FitBox {
}
class FitBoxPercentage {
    constructor({ x1, x2, y1, y2 }) {
        this.x1 = x1;
        this.x2 = x2;
        this.y1 = y1;
        this.y2 = y2;
    }
    toFitBox() {
        return {
            image_percentage: {
                x1: this.x1,
                y1: this.y1,
                x2: this.x2,
                y2: this.y2,
            },
        };
    }
}
exports.FitBoxPercentage = FitBoxPercentage;
class FitBoxMargin {
    constructor({ top = 0, left = 0, right = 0, bottom = 0, }) {
        this.top = top;
        this.left = left;
        this.right = right;
        this.bottom = bottom;
    }
    toFitBox() {
        return {
            image_margins: {
                left: this.left,
                top: this.top,
                right: this.right,
                bottom: this.bottom,
            },
        };
    }
}
exports.FitBoxMargin = FitBoxMargin;
class Watermark {
    constructor(ioID, { gravity, mode, box, opacity, hint }) {
        if (opacity > 1 || opacity < 0)
            throw new Error('invalid opacity value');
        this.ioID = ioID;
        this.gravity = gravity;
        this.fitMode = mode;
        this.fitBox = box;
        this.opacity = opacity;
        this.hint = hint;
    }
    toStep() {
        var _a, _b, _c;
        return {
            watermark: {
                io_id: this.ioID,
                gravity: (_a = this.gravity) === null || _a === void 0 ? void 0 : _a.toGravity(),
                fit_mode: this.fitMode,
                fit_box: (_b = this.fitBox) === null || _b === void 0 ? void 0 : _b.toFitBox(),
                opacity: this.opacity,
                hints: (_c = this.hint) === null || _c === void 0 ? void 0 : _c.toHint(),
            },
        };
    }
}
exports.Watermark = Watermark;
class CommandString {
    constructor(command, encode = null, decode = null) {
        this.command = command;
        this.decode = decode;
        this.encode = encode;
    }
    toStep() {
        return {
            command_string: {
                kind: 'ir4',
                value: this.command,
                decode: this.decode,
                encode: this.encode,
            },
        };
    }
}
exports.CommandString = CommandString;
class WhiteBalance {
    constructor(threshold) {
        this.threshold = threshold;
    }
    toStep() {
        return {
            white_balance_histogram_area_threshold_srgb: {
                threshold: this.threshold,
            },
        };
    }
}
exports.WhiteBalance = WhiteBalance;
var ColorFilterSRGBType;
(function (ColorFilterSRGBType) {
    ColorFilterSRGBType["GrayscaleNtsc"] = "grayscale_ntsc";
    ColorFilterSRGBType["GrayscaleFlat"] = "grayscale_flat";
    ColorFilterSRGBType["GrayscaleBt709"] = "grayscale_bt709";
    ColorFilterSRGBType["GrayscaleRY"] = "grayscale_ry";
    ColorFilterSRGBType["Invert"] = "invert";
})(ColorFilterSRGBType = exports.ColorFilterSRGBType || (exports.ColorFilterSRGBType = {}));
var ColorFilterSRGBValueType;
(function (ColorFilterSRGBValueType) {
    ColorFilterSRGBValueType["Alpha"] = "alpha";
    ColorFilterSRGBValueType["Contrast"] = "contrast";
    ColorFilterSRGBValueType["Brightness"] = "brightness";
})(ColorFilterSRGBValueType = exports.ColorFilterSRGBValueType || (exports.ColorFilterSRGBValueType = {}));
class ColorFilterSRGBValue {
    constructor(value, valueType) {
        this.value = value;
        this.valueType = valueType;
    }
    toFilter() {
        return {
            [this.valueType]: this.value,
        };
    }
}
exports.ColorFilterSRGBValue = ColorFilterSRGBValue;
class ColorFilterSRGB {
    constructor(filter) {
        this.filterType = filter;
    }
    toStep() {
        return {
            color_filter_srgb: typeof this.filterType === 'string'
                ? this.filterType
                : this.filterType.toFilter(),
        };
    }
}
exports.ColorFilterSRGB = ColorFilterSRGB;
class DrawExactImageTo {
    constructor({ x = 0, y = 0, w = 0, h = 0 }, blend, hint) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.blend = blend;
        this.hint = hint;
    }
    toStep() {
        var _a;
        return {
            draw_image_exact: {
                x: this.x,
                y: this.y,
                w: this.w,
                h: this.h,
                blend: this.blend,
                hints: (_a = this.hint) === null || _a === void 0 ? void 0 : _a.toHint(),
            },
        };
    }
}
exports.DrawExactImageTo = DrawExactImageTo;
var CompositingMode;
(function (CompositingMode) {
    CompositingMode["Compose"] = "compose";
    CompositingMode["Overwrite"] = "overwrite";
})(CompositingMode = exports.CompositingMode || (exports.CompositingMode = {}));
class CopyRectangle {
    constructor({ x = 0, y = 0, w = 0, h = 0 }, fromX, fromY) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.fromX = fromX;
        this.fromY = fromY;
    }
    toStep() {
        return {
            copy_rect_to_canvas: {
                from_x: this.fromX,
                from_y: this.fromY,
                w: this.w,
                h: this.h,
                x: this.x,
                y: this.y,
            },
        };
    }
}
exports.CopyRectangle = CopyRectangle;
class IOOperation {
}
exports.IOOperation = IOOperation;
class FromFile {
    constructor(filename) {
        this.filename = filename;
    }
    toIOBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
            let file = fs.promises.readFile(this.filename);
            return (yield file).buffer;
        });
    }
    get ioID() {
        return this.ioId;
    }
    setIOID(id, direction) {
        this.ioId = id;
        this.direction = direction;
    }
    toIOID() {
        return {
            io_id: this.ioId,
            direction: this.direction,
            io: 'placeholder',
        };
    }
    toOutput(buffer, collector) {
        return __awaiter(this, void 0, void 0, function* () {
            yield fs.promises.writeFile(this.filename, Buffer.from(buffer));
        });
    }
}
exports.FromFile = FromFile;
class FromStream {
    constructor(str) {
        this.internalStream = str;
    }
    toIOBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer = yield str(this.internalStream);
            return buffer.buffer;
        });
    }
    toIOID() {
        return {
            io_id: this.ioId,
            direction: this.direction,
            io: 'placeholder',
        };
    }
    setIOID(id, direction) {
        this.ioId = id;
        this.direction = direction;
    }
    get ioID() {
        return this.ioId;
    }
    toOutput(buffer, collector) {
        return new Promise((resolve, reject) => {
            const asWritable = this.internalStream;
            if (typeof asWritable.end === 'function') {
                asWritable.on('finish', resolve);
                asWritable.on('error', reject);
                asWritable.end(Buffer.from(buffer));
            }
            else {
                resolve();
            }
        });
    }
}
exports.FromStream = FromStream;
class FromBuffer {
    constructor(buf, key) {
        this.buffer = buf;
        this.key = key;
    }
    toIOBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.buffer.buffer;
        });
    }
    toIOID() {
        return {
            io_id: this.ioId,
            direction: this.direction,
            io: 'placeholder',
        };
    }
    setIOID(id, direction) {
        this.ioId = id;
        this.direction = direction;
    }
    get ioID() {
        return this.ioId;
    }
    toOutput(buffer, collector) {
        return __awaiter(this, void 0, void 0, function* () {
            collector[this.key] = Buffer.from(buffer);
        });
    }
}
exports.FromBuffer = FromBuffer;
class FromURL {
    constructor(url) {
        this.url = url;
    }
    toIOBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
            let file = axios_1.default.get(this.url, {
                responseType: 'arraybuffer',
            });
            return (yield file).data.buffer;
        });
    }
    get ioID() {
        return this.ioId;
    }
    setIOID(id, direction) {
        this.ioId = id;
        this.direction = direction;
    }
    toIOID() {
        return {
            io_id: this.ioId,
            direction: this.direction,
            io: 'placeholder',
        };
    }
    toOutput(buffer, collector) {
        return __awaiter(this, void 0, void 0, function* () {
            yield axios_1.default.post(this.url, Buffer.from(buffer));
        });
    }
}
exports.FromURL = FromURL;
class ReSample {
    constructor(w, h, hint = null) {
        this.w = w;
        this.h = h;
        this.hint = hint;
    }
    toStep() {
        var _a;
        return {
            resample_2d: {
                w: this.w,
                h: this.h,
                hints: (_a = this.hint) === null || _a === void 0 ? void 0 : _a.toHint(),
            },
        };
    }
}
exports.ReSample = ReSample;
class DecodeOptions {
    constructor() {
        this.setJPEGDownscaleHintUsed = false;
        this.discardColorProfileUsed = false;
        this.ignoreColorProfileErrorUsed = false;
        this.setJPEGDownscaleHintUsed = false;
        this.commands = [];
    }
    toDecodeOptions() {
        return this.commands;
    }
    setJPEGDownscaleHint(width, height, { scaleLumaSpatially = true, gammaCorrectForSrgbDuringSpatialLumaScaling = true, } = {}) {
        if (this.setJPEGDownscaleHintUsed)
            throw new Error('duplicate options are not allowed');
        this.setJPEGDownscaleHintUsed = true;
        this.commands.push({
            jpeg_downscale_hints: {
                width,
                height,
                scale_luma_spatially: scaleLumaSpatially,
                gamma_correct_for_srgb_during_spatial_luma_scaling: gammaCorrectForSrgbDuringSpatialLumaScaling,
            },
        });
        return this;
    }
    discardColorProfile() {
        if (this.discardColorProfileUsed)
            throw new Error('duplicate options are not allowed');
        this.discardColorProfileUsed = true;
        this.commands.push('discard_color_profile');
        return this;
    }
    ignoreColorProfileError() {
        if (this.ignoreColorProfileErrorUsed)
            throw new Error('duplicate options are not allowed');
        this.ignoreColorProfileErrorUsed = true;
        this.commands.push('ignore_color_profile_errors');
        return this;
    }
    setWebpDecoderHints(width, height) {
        if (this.setWebpDecoderHintsUsed)
            throw new Error('duplicate options are not allowed');
        this.setWebpDecoderHintsUsed = true;
        this.commands.push({
            webp_decoder_hints: {
                width,
                height,
            },
        });
        return this;
    }
}
exports.DecodeOptions = DecodeOptions;
//# sourceMappingURL=types.js.map