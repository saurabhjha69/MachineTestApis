"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Steps = void 0;
const types_1 = require("./types");
const job_1 = require("./job");
class Steps {
    constructor(operation = null, options) {
        this.vertex = [];
        this.inputs = [];
        this.outputs = [];
        this.last = 0;
        this.graph = new Graph();
        this.ioID = 0;
        if (operation) {
            operation.setIOID(this.ioID, types_1.Direction.in);
            const decode = new types_1.Decode(this.ioID, options);
            this.inputs.push(operation);
            this.vertex.push(decode);
            this.graph.addVertex(0);
            this.last = 0;
            this.ioID++;
            this.decodeValue = true;
        }
        else {
            this.decodeValue = false;
        }
    }
    decode(operation, options) {
        this.decodeValue = true;
        operation.setIOID(this.ioID, types_1.Direction.in);
        const decode = new types_1.Decode(this.ioID, options);
        this.inputs.push(operation);
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(decode);
        this.last = this.vertex.length - 1;
        this.ioID++;
        return this;
    }
    constrain(constraint) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(constraint);
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    constrainWithin(width, height) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.Constrain(types_1.ConstrainMode.Within, width, height));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    branch(f) {
        let last = this.last;
        f(this);
        this.last = last;
        return this;
    }
    drawImageExactTo(f, coordinates, blend, hint) {
        let last = this.last;
        f(this);
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.DrawExactImageTo(coordinates, blend, hint));
        this.graph.addEdge(this.vertex.length - 1, last, 'input');
        this.graph.addEdge(this.vertex.length - 1, this.last, 'canvas');
        this.last = this.vertex.length - 1;
        return this;
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.decodeValue)
                throw new Error('decode must be the first node in graph');
            let job = new job_1.NativeJob();
            yield Promise.all(this.inputs.map((ioData) => __awaiter(this, void 0, void 0, function* () {
                let file = yield ioData.toIOBuffer();
                job.addInputBytes(ioData.ioID, file);
            })));
            this.outputs.forEach((ioData) => {
                job.addOutputBuffer(ioData.ioID);
            });
            let nodes = this.vertex.reduce((acc, step, i) => {
                acc[i.toString()] = step.toStep();
                acc;
                return acc;
            }, {});
            let s = JSON.stringify({
                framewise: {
                    graph: {
                        nodes: nodes,
                        edges: this.graph.toEdge(),
                    },
                },
            });
            yield job.message('v0.1/execute', s);
            let collector = {};
            yield Promise.all(this.outputs.map((ioData) => __awaiter(this, void 0, void 0, function* () {
                let arrayBuffer = job.getOutputBufferBytes(ioData.ioID);
                return yield ioData.toOutput(arrayBuffer, collector);
            })));
            return collector;
        });
    }
    rotate90() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.Rotate90());
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    rotate180() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.Rotate180());
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    rotate270() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.Rotate270());
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    rotate(rotate) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(rotate);
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    region(regionData) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(regionData);
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    cropWhiteSpace(data) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(data);
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    fillRect(data) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(data);
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    expandCanvas(data) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(data);
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    flipHorizontal() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.FlipH());
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    flipVertical() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.FlipV());
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    watermark(operation, watermarkOption) {
        operation.setIOID(this.ioID, types_1.Direction.in);
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.inputs.push(operation);
        this.vertex.push(new types_1.Watermark(this.ioID, watermarkOption));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        this.ioID++;
        return this;
    }
    encode(operation, decodeData) {
        operation.setIOID(this.ioID, types_1.Direction.out);
        const encoder = new types_1.Encode(decodeData, this.ioID);
        this.outputs.push(operation);
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(encoder);
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        this.ioID++;
        return this;
    }
    colorFilterInvert() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ColorFilterSRGB(types_1.ColorFilterSRGBType.Invert));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    colorFilterGrayscaleRY() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ColorFilterSRGB(types_1.ColorFilterSRGBType.GrayscaleRY));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    colorFilterGrayscaleBt709() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ColorFilterSRGB(types_1.ColorFilterSRGBType.GrayscaleBt709));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    colorFilterGrayscaleFlat() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ColorFilterSRGB(types_1.ColorFilterSRGBType.GrayscaleFlat));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    colorFilterGrayscaleNtsc() {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ColorFilterSRGB(types_1.ColorFilterSRGBType.GrayscaleNtsc));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    colorFilterAlpha(value) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ColorFilterSRGB(new types_1.ColorFilterSRGBValue(value, types_1.ColorFilterSRGBValueType.Alpha)));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    colorFilterBrightness(value) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ColorFilterSRGB(new types_1.ColorFilterSRGBValue(value, types_1.ColorFilterSRGBValueType.Brightness)));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    colorFilterContrast(value) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ColorFilterSRGB(new types_1.ColorFilterSRGBValue(value, types_1.ColorFilterSRGBValueType.Contrast)));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    colorFilter(value) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ColorFilterSRGB(value));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    copyRectangle(f, coordinates, fromX, fromY) {
        let last = this.last;
        f(this);
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.CopyRectangle(coordinates, fromX, fromY));
        this.graph.addEdge(this.vertex.length - 1, last, 'input');
        this.graph.addEdge(this.vertex.length - 1, this.last, 'canvas');
        this.last = this.vertex.length - 1;
        return this;
    }
    command(value) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.CommandString(value));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
    executeCommand(commandValue, input, output) {
        return __awaiter(this, void 0, void 0, function* () {
            let job = new job_1.NativeJob();
            const value = yield input.toIOBuffer();
            job.addInputBytes(0, value);
            job.addOutputBuffer(1);
            let s = JSON.stringify({
                framewise: {
                    steps: [new types_1.CommandString(commandValue, 1, 0).toStep()],
                },
            });
            yield job.message('v0.1/execute', s);
            let collector = {};
            let buffer = job.getOutputBufferBytes(1);
            yield output.toOutput(buffer, collector);
            return collector;
        });
    }
    distort(w, h, hint = null) {
        if (!this.decodeValue)
            throw new Error('decode must be the first node in graph');
        this.graph.addVertex(this.vertex.length);
        this.vertex.push(new types_1.ReSample(w, h, hint));
        this.graph.addEdge(this.vertex.length - 1, this.last);
        this.last = this.vertex.length - 1;
        return this;
    }
}
exports.Steps = Steps;
class Graph {
    constructor() {
        this._internal = new Map();
    }
    addVertex(vertex) {
        if (this._internal.has(vertex))
            throw new Error('vertex is already present');
        else
            this._internal.set(vertex, []);
    }
    addEdge(to, from, type = 'input') {
        if (!this._internal.has(from) || !this._internal.has(to))
            throw new Error('vertex not found in graph');
        this._internal.get(from).push({ to, type });
    }
    toEdge() {
        let arr = [];
        for (const element of this._internal.entries()) {
            for (const i of element[1]) {
                arr.push({
                    to: i.to,
                    from: element[0],
                    kind: i.type,
                });
            }
        }
        return arr;
    }
}
//# sourceMappingURL=json.js.map